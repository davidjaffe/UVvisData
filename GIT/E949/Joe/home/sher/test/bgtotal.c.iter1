/*
 *    File:  bglike.c
 * Purpose:  define the inside-the-box (and outside-the-box)
 *           global background function
 *   Usage:  > bglike
 *
 * History:  2001 Jul 25  PB  created
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/*
 *  Filenames for the ascii data files which contain N and A values
 *  for the 7 background functions.  Note that the functions are designed
 *  such that:
 *  - the pv and kp2 functions are linear in Kp2 background;
 *  - the td function is linear in both Km2 range-tail and
 *    muon-band background;
 *  - the km2t function is linear in Km2 range-tail background;
 *  - the km2b function is linear in muon-band background;
 *  - the bm1 function is linear in the sum of single-beam kaon- and
 *    pion-entering background plus charge-exchange background;
 *  - the bm2 function is linear in the sum of double-beam kaon- and
 *    pion-entering background.
 *  This is why there are 7 functions but 8 background types.
 *  The code below is written specifically with these particular
 *  functions in mind.  The code is also written on the assumption
 *  that N and A values are tabulated in decreasing order.
 */
char FilePv[15] = "pvfunc.dat";
char FileKp2[15] = "kp2func.dat";
char FileTd[15] = "tdfunc.dat";
char FileKm2t[15] = "km2tfunc.dat";
char FileKm2b[15] = "km2bfunc.dat";
char FileBm1[15] = "bm1func.dat";
char FileBm2[15] = "bm2func.dat";

/*
 *  Expected background levels at the final box position for the
 *  8 background types.
 */
/*
 *  based on 1/3 + 2/3 1998:
 */
float BoxBgKp2 = 0.035;
float BoxBgKm2t = 0.024;
float BoxBgKm2b = 0.008;
float BoxBgBm1k = 0.00144;
float BoxBgBm1p = 0.00023;
float BoxBgCex = 0.01224;
float BoxBgBm2k = 0.0000918;
float BoxBgBm2p = 0.0000227;
/*
 *  based on 2/3 1998:
 *
float BoxBgKp2 = 0.035;
float BoxBgKm2t = 0.024;
float BoxBgKm2b = 0.008;
float BoxBgBm1 = 0.0025;
float BoxBgBm2 = 0.00005;
float BoxBgCex = 0.0122;
*/

/*
 *  Function (N) values at the final box position for the 7 functions.
 *  These must be EXACTLY the same as the correponding values in the data
 *  files above.
 */
float BoxFnPv = 1.0;
float BoxFnKp2 = 0.00318;
float BoxFnTd =  1.0;
float BoxFnKm2t = 0.8405167E-02;
float BoxFnKm2b =  0.3284450E-02;
float BoxFnBm1 =  1.0;
float BoxFnBm2 =  1.0;

/*
 *  Template structure for the Kp2 and Km2 ("kaon-decay")
 *  background functions.
 */
struct dkvalue {
   float n;
   float a;
   struct dkvalue *next;
   struct dkvalue *prev;
};
typedef struct dkvalue DKVALUE;
typedef DKVALUE *PTRDKVALUE;

struct dkfunc {
   int nvalues;
   PTRDKVALUE head,box,tail;
};
typedef struct dkfunc DKFUNC;

/*
 *  Template structure for the beam background functions.
 */
struct bmvalue {
   float n;
   float a;
   float kaon;
   float pion;
   float cex;
   struct bmvalue *next;
   struct bmvalue *prev;
};
typedef struct bmvalue BMVALUE;
typedef BMVALUE *PTRBMVALUE;

struct bmfunc {
   int nvalues;
   PTRBMVALUE head,box,tail;
};
typedef struct bmfunc BMFUNC;

/*
 *  Template structure for the total background function.
 */
struct totvalue {
   float n;
   float a;
   float kp2;
   float km2t;
   float km2b;
   float bm1k;
   float bm1p;
   float cex;
   float bm2k;
   float bm2p;
   PTRDKVALUE ptrpv,ptrkp2,ptrtd,ptrkm2t,ptrkm2b;
   PTRBMVALUE ptrbm1,ptrbm2;
   struct totvalue *next;
   struct totvalue *prev;
};
typedef struct totvalue TOTVALUE;
typedef TOTVALUE *PTRTOTVALUE;

struct totfunc {
   int nvalues;
   PTRTOTVALUE head,box,tail;
};
typedef struct totfunc TOTFUNC;

/*
 *  Create the total function.
 */
int main(void)
{
   FILE *fptr;
   DKFUNC bgpv,bgkp2,bgtd,bgkm2t,bgkm2b;
   BMFUNC bgbm1,bgbm2;
   TOTFUNC bgtotal;
   PTRDKVALUE p;
   PTRBMVALUE q;
   PTRTOTVALUE t;
   float kp2old,km2told,km2bold,bm1kold,bm1pold,cexold,bm2kold,bm2pold;
   float kp2new,km2tnew,km2bnew,bm1knew,bm1pnew,cexnew,bm2knew,bm2pnew;
   float totold,totnew,accold,accnew;
   float Rpv,Apv,Rkp2,Akp2,Rtd,Atd,Rkm2t,Akm2t,Rkm2b,Akm2b;
   float Rbm1k,Rbm1p,Rcex,Abm1,Rbm2k,Rbm2p,Abm2;
   float RA,RAmax;
   float d,tot;
   int i;

   /*
    *  Initialize.
    */
   bgpv.nvalues = 0;
   bgpv.head = bgpv.box = bgpv.tail = NULL;
   bgkp2.nvalues = 0;
   bgkp2.head = bgkp2.box = bgkp2.tail = NULL;
   bgtd.nvalues = 0;
   bgtd.head = bgtd.box = bgtd.tail = NULL;
   bgkm2t.nvalues = 0;
   bgkm2t.head = bgkm2t.box = bgkm2t.tail = NULL;
   bgkm2b.nvalues = 0;
   bgkm2b.head = bgkm2b.box = bgkm2b.tail = NULL;
   bgbm1.nvalues = 0;
   bgbm1.head = bgbm1.box = bgbm1.tail = NULL;
   bgbm2.nvalues = 0;
   bgbm2.head = bgbm2.box = bgbm2.tail = NULL;
   bgtotal.nvalues = 0;
   bgtotal.head = bgtotal.box = bgtotal.tail = NULL;

   /*
    *  Read the individual background functions into structures.
    */
   if ((fptr = fopen(FilePv,"r")) == NULL) {
      printf("Not using PV function, because %s does not exist. \n",FilePv);
   } else {
      bgpv.head = malloc(sizeof(DKVALUE));
      bgpv.head -> prev = NULL;
      bgpv.tail = bgpv.head;
      p = bgpv.head;
      while (fscanf(fptr,"%f %f",&(p->n),&(p->a)) == 2) {
         (p -> n) = 46.918/(p -> n);
         bgpv.nvalues += 1;
         if ((p -> n) == BoxFnPv) {
            bgpv.box = p;
         }
         bgpv.tail = p;
         bgpv.tail -> next = malloc(sizeof(DKVALUE));
         bgpv.tail -> next -> prev = bgpv.tail;
         p = bgpv.tail -> next;
      }
      free(p);
      if (bgpv.nvalues == 0) {
         bgpv.head = NULL;
         bgpv.tail = NULL;
      } else {
         bgpv.tail -> next = NULL;
      }
   }

   if ((fptr = fopen(FileKp2,"r")) == NULL) {
      printf("Not using Kp2 function, because %s does not exist. \n",FileKp2);
   } else {
      bgkp2.head = malloc(sizeof(DKVALUE));
      bgkp2.head -> prev = NULL;
      bgkp2.tail = bgkp2.head;
      p = bgkp2.head;
      while (fscanf(fptr,"%f %f %f %f %f",&d,&d,&d,&(p->a),&(p->n)) == 5) {
         bgkp2.nvalues += 1;
         if ((p -> n) == BoxFnKp2) {
            bgkp2.box = p;
         }
         bgkp2.tail = p;
         bgkp2.tail -> next = malloc(sizeof(DKVALUE));
         bgkp2.tail -> next -> prev = bgkp2.tail;
         p = bgkp2.tail -> next;
      }
      free(p);
      if (bgkp2.nvalues == 0) {
         bgkp2.head = NULL;
         bgkp2.tail = NULL;
      } else {
         bgkp2.tail -> next = NULL;
      }
   }

   if ((fptr = fopen(FileTd,"r")) == NULL) {
      printf("Not using TD function, because %s does not exist. \n",FileTd);
   } else {
      bgtd.head = malloc(sizeof(DKVALUE));
      bgtd.head -> prev = NULL;
      bgtd.tail = bgtd.head;
      p = bgtd.head;
      while (fscanf(fptr,"%f %f %f",&(p->n),&(p->a),&d) == 3) {
         (p -> n) /= 39;
         bgtd.nvalues += 1;
         if ((p -> n) == BoxFnTd) {
            bgtd.box = p;
         }
         bgtd.tail = p;
         bgtd.tail -> next = malloc(sizeof(DKVALUE));
         bgtd.tail -> next -> prev = bgtd.tail;
         p = bgtd.tail -> next;
      }
      free(p);
      if (bgtd.nvalues == 0) {
         bgtd.head = NULL;
         bgtd.tail = NULL;
      } else {
         bgtd.tail -> next = NULL;
      }
   }

   if ((fptr = fopen(FileKm2t,"r")) == NULL) {
      printf("Not using Km2 range-tail function, because %s does not exist. \n",FileKm2t);
   } else {
      bgkm2t.head = malloc(sizeof(DKVALUE));
      bgkm2t.head -> prev = NULL;
      bgkm2t.tail = bgkm2t.head;
      p = bgkm2t.head;
      while (fscanf(fptr,"%f %f",&(p->n),&(p->a)) == 2) {
         bgkm2t.nvalues += 1;
         if ((p -> n) == BoxFnKm2t) {
            bgkm2t.box = p;
         }
         bgkm2t.tail = p;
         bgkm2t.tail -> next = malloc(sizeof(DKVALUE));
         bgkm2t.tail -> next -> prev = bgkm2t.tail;
         p = bgkm2t.tail -> next;
      }
      free(p);
      if (bgkm2t.nvalues == 0) {
         bgkm2t.head = NULL;
         bgkm2t.tail = NULL;
      } else {
         bgkm2t.tail -> next = NULL;
      }
   }

   if ((fptr = fopen(FileKm2b,"r")) == NULL) {
      printf("Not using muon-band function, because %s does not exist. \n",FileKm2b);
   } else {
      bgkm2b.head = malloc(sizeof(DKVALUE));
      bgkm2b.head -> prev = NULL;
      bgkm2b.tail = bgkm2b.head;
      p = bgkm2b.head;
      while (fscanf(fptr,"%f %f",&(p->n),&(p->a)) == 2) {
         bgkm2b.nvalues += 1;
         if ((p -> n) == BoxFnKm2b) {
            bgkm2b.box = p;
         }
         bgkm2b.tail = p;
         bgkm2b.tail -> next = malloc(sizeof(DKVALUE));
         bgkm2b.tail -> next -> prev = bgkm2b.tail;
         p = bgkm2b.tail -> next;
      }
      free(p);
      if (bgkm2b.nvalues == 0) {
         bgkm2b.head = NULL;
         bgkm2b.tail = NULL;
      } else {
         bgkm2b.tail -> next = NULL;
      }
   }

   if ((fptr = fopen(FileBm1,"r")) == NULL) {
      printf("Not using Bm1 function, because %s does not exist. \n",FileBm1);
   } else {
      bgbm1.head = malloc(sizeof(BMVALUE));
      bgbm1.head -> prev = NULL;
      bgbm1.tail = bgbm1.head;
      q = bgbm1.head;
      while (fscanf(fptr,"%f %f %f %f %f %f %f",&d, \
             &(q->kaon),&(q->pion),&(q->cex),&d,&(q->n),&(q->a)) == 7) {
         q -> kaon *= 0.01;
         q -> pion *= 0.01;
         q -> cex *= 0.01;
         bgbm1.nvalues += 1;
         if ((q -> n) == BoxFnBm1) {
            bgbm1.box = q;
         }
         bgbm1.tail = q;
         bgbm1.tail -> next = malloc(sizeof(BMVALUE));
         bgbm1.tail -> next -> prev = bgbm1.tail;
         q = bgbm1.tail -> next;
      }
      free(q);
      if (bgbm1.nvalues == 0) {
         bgbm1.head = NULL;
         bgbm1.tail = NULL;
      } else {
         bgbm1.tail -> next = NULL;
      }
   }

   if ((fptr = fopen(FileBm2,"r")) == NULL) {
      printf("Not using Bm2 function, because %s does not exist. \n",FileBm2);
   } else {
      bgbm2.head = malloc(sizeof(BMVALUE));
      bgbm2.head -> prev = NULL;
      bgbm2.tail = bgbm2.head;
      q = bgbm2.head;
      while (fscanf(fptr,"%f %f %f %f %f %f",&d, \
             &(q->kaon),&(q->pion),&d,&(q->n),&(q->a)) == 6) {
         q -> cex = 0.;
         q -> kaon *= 0.01;
         q -> pion *= 0.01;
         bgbm2.nvalues += 1;
         if ((q -> n) == BoxFnBm2) {
            bgbm2.box = q;
         }
         bgbm2.tail = q;
         bgbm2.tail -> next = malloc(sizeof(BMVALUE));
         bgbm2.tail -> next -> prev = bgbm2.tail;
         q = bgbm2.tail -> next;
      }
      free(q);
      if (bgbm2.nvalues == 0) {
         bgbm2.head = NULL;
         bgbm2.tail = NULL;
      } else {
         bgbm2.tail -> next = NULL;
      }
   }

   /*
    *  Define the total background at the box.
    */
   bgtotal.box = malloc(sizeof(TOTVALUE));
   bgtotal.head = bgtotal.box;
   t = bgtotal.box;
   t -> n = 1.;
   t -> a = 1.;
   t -> kp2 = BoxBgKp2;
   t -> km2t = BoxBgKm2t;
   t -> km2b = BoxBgKm2b;
   t -> bm1k = BoxBgBm1k;
   t -> bm1p = BoxBgBm1p;
   t -> cex = BoxBgCex;
   t -> bm2k = BoxBgBm2k;
   t -> bm2p = BoxBgBm2p;
   t -> ptrpv = bgpv.box;
   t -> ptrkp2 = bgkp2.box;
   t -> ptrtd = bgtd.box;
   t -> ptrkm2t = bgkm2t.box;
   t -> ptrkm2b = bgkm2b.box;
   t -> ptrbm1 = bgbm1.box;
   t -> ptrbm2 = bgbm2.box;
   t -> next = NULL;
   t -> prev = NULL;
   bgtotal.nvalues += 1;

   /*
    *  Loop over all the functions, and tighten them one at a time
    *  to define the global background function inside the box.
    *  The one function which gives the largest absolute decrease in
    *  total background level per absolute decrease in total acceptance
    *  is the function that is tightened at each step.
    *
    *  In the following code, it is assumed that the functions are
    *  tabulated/stored in order of decreasing background and acceptance.
    */
   while (((t -> ptrpv -> next) != NULL) || \
          ((t -> ptrkp2 -> next) != NULL) || \
          ((t -> ptrtd -> next) != NULL) || \
          ((t -> ptrkm2t -> next) != NULL) || \
          ((t -> ptrkm2b -> next) != NULL) || \
          ((t -> ptrbm1 -> next) != NULL) || \
          ((t -> ptrbm2 -> next) != NULL)) {

      t -> next = malloc(sizeof(TOTVALUE));

      kp2old = (t -> kp2);
      km2told = (t -> km2t);
      km2bold = (t -> km2b);
      bm1kold = (t -> bm1k);
      bm1pold = (t -> bm1p);
      cexold = (t -> cex);
      bm2kold = (t -> bm2k);
      bm2pold = (t -> bm2p);
      totold = kp2old + km2told + km2bold + \
               bm1kold + bm1pold + cexold + bm2kold + bm2pold;
      accold = (t -> a);

      RAmax = 0.;

      /*
       *  Get the new background level and acceptance
       *  by tightening the PV function.
       */
      if ((t -> ptrpv -> next) != NULL) {
         Rpv = 1;
         if (t -> ptrpv -> next -> n != 0)
            Rpv = (t -> ptrpv -> n)/(t -> ptrpv -> next -> n);
         Apv = 0;
         if (t -> ptrpv -> a != 0)
            Apv = (t -> ptrpv -> next -> a)/(t -> ptrpv -> a);

         kp2new = kp2old/Rpv;
         km2tnew = km2told*Apv;
         km2bnew = km2bold*Apv;
         bm1knew = bm1kold*Apv;
         bm1pnew = bm1pold*Apv;
         cexnew = cexold*Apv;
         bm2knew = bm2kold*Apv;
         bm2pnew = bm2pold*Apv;
         totnew = kp2new + km2tnew + km2bnew + \
                  bm1knew + bm1pnew + cexnew + bm2knew + bm2pnew;
         accnew = accold*Apv;
         if (accold == accnew) {
            if (totnew == totold) {
               RA = 999.;                     /* repeated entry -- skip */
	    } else {
               RA = (totold-totnew)/0.000001; /* more R, same A */
	    }
	 } else {
            if (totnew == totold) {
               RA = 999.;                     /* same R, less A -- skip */
	    } else {
               RA = (totold-totnew)/(accold-accnew); /* this should always */
                                                     /* be >0 and <infinity */
                                                     /* if the function has */
                                                     /* been tabulated */
                                                     /* properly */
	    }
	 }
         printf("PV %f ", RA);

         if (RA > RAmax) {
            RAmax = RA;
            (t -> next -> n) = (totnew/totold)*(t -> n);
            t -> next -> a = (accnew/accold)*(t -> a);
            t -> next -> kp2 = kp2new;
            t -> next -> km2t = km2tnew;
            t -> next -> km2b = km2bnew;
            t -> next -> bm1k = bm1knew;
            t -> next -> bm1p = bm1pnew;
            t -> next -> cex = cexnew;
            t -> next -> bm2k = bm2knew;
            t -> next -> bm2p = bm2pnew;
            t -> next -> ptrpv = t -> ptrpv -> next;
            t -> next -> ptrkp2 = t -> ptrkp2;
            t -> next -> ptrtd = t -> ptrtd;
            t -> next -> ptrkm2t = t -> ptrkm2t;
            t -> next -> ptrkm2b = t -> ptrkm2b;
            t -> next -> ptrbm1 = t -> ptrbm1;
            t -> next -> ptrbm2 = t -> ptrbm2;
         }
      } 

      /*
       *  Get the new background level and acceptance
       *  by tightening the Kp2 kinematic function.
       */
      if ((t -> ptrkp2 -> next) != NULL) {
         Rkp2 = 1;
         if (t -> ptrkp2 -> next -> n != 0)
            Rkp2 = (t -> ptrkp2 -> n)/(t -> ptrkp2 -> next -> n);
         Akp2 = 0;
         if (t -> ptrkp2 -> a != 0)
            Akp2 = (t -> ptrkp2 -> next -> a)/(t -> ptrkp2 -> a);

         kp2new = kp2old/Rkp2;
         km2tnew = km2told;
         km2bnew = km2bold;
         bm1knew = bm1kold*Akp2;
         bm1pnew = bm1pold*Akp2;
         cexnew = cexold*Akp2;
         bm2knew = bm2kold*Akp2;
         bm2pnew = bm2pold*Akp2;
         totnew = kp2new + km2tnew + km2bnew + \
                  bm1knew + bm1pnew + cexnew + bm2knew + bm2pnew;
         accnew = accold*Akp2;
         if (accold == accnew) {
            if (totnew == totold) {
               RA = 999.;                     /* repeated entry -- skip */
	    } else {
               RA = (totold-totnew)/0.000001; /* more R, same A */
	    }
	 } else {
            if (totnew == totold) {
               RA = 999.;                     /* same R, less A -- skip */
	    } else {
               RA = (totold-totnew)/(accold-accnew); /* this should always */
                                                     /* be >0 and <infinity */
                                                     /* if the function has */
                                                     /* been tabulated */
                                                     /* properly */
	    }
	 }
         printf("Kp2 %f ", RA);

         if (RA > RAmax) {
            RAmax = RA;
            t -> next -> n = (totnew/totold)*(t -> n);
            t -> next -> a = (accnew/accold)*(t -> a);
            t -> next -> kp2 = kp2new;
            t -> next -> km2t = km2tnew;
            t -> next -> km2b = km2bnew;
            t -> next -> bm1k = bm1knew;
            t -> next -> bm1p = bm1pnew;
            t -> next -> cex = cexnew;
            t -> next -> bm2k = bm2knew;
            t -> next -> bm2p = bm2pnew;
            t -> next -> ptrpv = t -> ptrpv;
            t -> next -> ptrkp2 = t -> ptrkp2 -> next;
            t -> next -> ptrtd = t -> ptrtd;
            t -> next -> ptrkm2t = t -> ptrkm2t;
            t -> next -> ptrkm2b = t -> ptrkm2b;
            t -> next -> ptrbm1 = t -> ptrbm1;
            t -> next -> ptrbm2 = t -> ptrbm2;
         }
      }

      /*
       *  Get the new background level and acceptance
       *  by tightening the TD function.
       */
      if ((t -> ptrtd -> next) != NULL) {
         Rtd = 1;
         if (t -> ptrtd -> next -> n != 0)
            Rtd = (t -> ptrtd -> n)/(t -> ptrtd -> next -> n);
         Atd = 0;
         if (t -> ptrtd -> a != 0)
            Atd = (t -> ptrtd -> next -> a)/(t -> ptrtd -> a);

         kp2new = kp2old*Atd;
         km2tnew = km2told/Rtd;
         km2bnew = km2bold/Rtd;
         bm1knew = bm1kold*Atd;
         bm1pnew = bm1pold*Atd;
         cexnew = cexold*Atd;
         bm2knew = bm2kold*Atd;
         bm2pnew = bm2pold*Atd;
         totnew = kp2new + km2tnew + km2bnew + \
                  bm1knew + bm1pnew + cexnew + bm2knew + bm2pnew;
         accnew = accold*Atd;
         if (accold == accnew) {
            if (totnew == totold) {
               RA = 999.;                     /* repeated entry -- skip */
	    } else {
               RA = (totold-totnew)/0.000001; /* more R, same A */
	    }
	 } else {
            if (totnew == totold) {
               RA = 999.;                     /* same R, less A -- skip */
	    } else {
               RA = (totold-totnew)/(accold-accnew); /* this should always */
                                                     /* be >0 and <infinity */
                                                     /* if the function has */
                                                     /* been tabulated */
                                                     /* properly */
	    }
	 }
         printf("TD %f ", RA);

         if (RA > RAmax) {
            RAmax = RA;
            t -> next -> n = (totnew/totold)*(t -> n);
            t -> next -> a = (accnew/accold)*(t -> a);
            t -> next -> kp2 = kp2new;
            t -> next -> km2t = km2tnew;
            t -> next -> km2b = km2bnew;
            t -> next -> bm1k = bm1knew;
            t -> next -> bm1p = bm1pnew;
            t -> next -> cex = cexnew;
            t -> next -> bm2k = bm2knew;
            t -> next -> bm2p = bm2pnew;
            t -> next -> ptrpv = t -> ptrpv;
            t -> next -> ptrkp2 = t -> ptrkp2;
            t -> next -> ptrtd = t -> ptrtd -> next;
            t -> next -> ptrkm2t = t -> ptrkm2t;
            t -> next -> ptrkm2b = t -> ptrkm2b;
            t -> next -> ptrbm1 = t -> ptrbm1;
            t -> next -> ptrbm2 = t -> ptrbm2;
         }
      }

      /*
       *  Get the new background level and acceptance
       *  by tightening the Km2 range-tail kinematic function.
       */
      if ((t -> ptrkm2t -> next) != NULL) {
         Rkm2t = 1;
         if (t -> ptrkm2t -> next -> n != 0)
            Rkm2t = (t -> ptrkm2t -> n)/(t -> ptrkm2t -> next -> n);
         Akm2t = 0;
         if (t -> ptrkm2t -> a != 0)
            Akm2t = (t -> ptrkm2t -> next -> a)/(t -> ptrkm2t -> a);

         kp2new = kp2old;
         km2tnew = km2told/Rkm2t;
         km2bnew = km2bold;
         bm1knew = bm1kold*Akm2t;
         bm1pnew = bm1pold*Akm2t;
         cexnew = cexold*Akm2t;
         bm2knew = bm2kold*Akm2t;
         bm2pnew = bm2pold*Akm2t;
         totnew = kp2new + km2tnew + km2bnew + \
                  bm1knew + bm1pnew + cexnew + bm2knew + bm2pnew;
         accnew = accold*Akm2t;
         if (accold == accnew) {
            if (totnew == totold) {
               RA = 999.;                     /* repeated entry -- skip */
	    } else {
               RA = (totold-totnew)/0.000001; /* more R, same A */
	    }
	 } else {
            if (totnew == totold) {
               RA = 999.;                     /* same R, less A -- skip */
	    } else {
               RA = (totold-totnew)/(accold-accnew); /* this should always */
                                                     /* be >0 and <infinity */
                                                     /* if the function has */
                                                     /* been tabulated */
                                                     /* properly */
	    }
	 }
         printf("Km2t %f ", RA);

         if (RA > RAmax) {
            RAmax = RA;
            t -> next -> n = (totnew/totold)*(t -> n);
            t -> next -> a = (accnew/accold)*(t -> a);
            t -> next -> kp2 = kp2new;
            t -> next -> km2t = km2tnew;
            t -> next -> km2b = km2bnew;
            t -> next -> bm1k = bm1knew;
            t -> next -> bm1p = bm1pnew;
            t -> next -> cex = cexnew;
            t -> next -> bm2k = bm2knew;
            t -> next -> bm2p = bm2pnew;
            t -> next -> ptrpv = t -> ptrpv;
            t -> next -> ptrkp2 = t -> ptrkp2;
            t -> next -> ptrtd = t -> ptrtd;
            t -> next -> ptrkm2t = t -> ptrkm2t -> next;
            t -> next -> ptrkm2b = t -> ptrkm2b;
            t -> next -> ptrbm1 = t -> ptrbm1;
            t -> next -> ptrbm2 = t -> ptrbm2;
         }
      }

      /*
       *  Get the new background level and acceptance
       *  by tightening the muon-band kinematic function.
       */
      if ((t -> ptrkm2b -> next) != NULL) {
         Rkm2b = 1;
         if (t -> ptrkm2b -> next -> n != 0)
            Rkm2b = (t -> ptrkm2b -> n)/(t -> ptrkm2b -> next -> n);
         Akm2b = 0;
         if (t -> ptrkm2b -> a != 0)
            Akm2b = (t -> ptrkm2b -> next -> a)/(t -> ptrkm2b -> a);

         kp2new = kp2old;
         km2tnew = km2told;
         km2bnew = km2bold/Rkm2b;
         bm1knew = bm1kold*Akm2b;
         bm1pnew = bm1pold*Akm2b;
         cexnew = cexold*Akm2b;
         bm2knew = bm2kold*Akm2b;
         bm2pnew = bm2pold*Akm2b;
         totnew = kp2new + km2tnew + km2bnew + \
                  bm1knew + bm1pnew + cexnew + bm2knew + bm2pnew;
         accnew = accold*Akm2b;
         if (accold == accnew) {
            if (totnew == totold) {
               RA = 999.;                     /* repeated entry -- skip */
	    } else {
               RA = (totold-totnew)/0.000001; /* more R, same A */
	    }
	 } else {
            if (totnew == totold) {
               RA = 999.;                     /* same R, less A -- skip */
	    } else {
               RA = (totold-totnew)/(accold-accnew); /* this should always */
                                                     /* be >0 and <infinity */
                                                     /* if the function has */
                                                     /* been tabulated */
                                                     /* properly */
	    }
	 }
         printf("Km2b %f ", RA);

         if (RA > RAmax) {
            RAmax = RA;
            t -> next -> n = (totnew/totold)*(t -> n);
            t -> next -> a = (accnew/accold)*(t -> a);
            t -> next -> kp2 = kp2new;
            t -> next -> km2t = km2tnew;
            t -> next -> km2b = km2bnew;
            t -> next -> bm1k = bm1knew;
            t -> next -> bm1p = bm1pnew;
            t -> next -> cex = cexnew;
            t -> next -> bm2k = bm2knew;
            t -> next -> bm2p = bm2pnew;
            t -> next -> ptrpv = t -> ptrpv;
            t -> next -> ptrkp2 = t -> ptrkp2;
            t -> next -> ptrtd = t -> ptrtd;
            t -> next -> ptrkm2t = t -> ptrkm2t;
            t -> next -> ptrkm2b = t -> ptrkm2b -> next;
            t -> next -> ptrbm1 = t -> ptrbm1;
            t -> next -> ptrbm2 = t -> ptrbm2;
         }
      }

      /*
       *  Get the new background level and acceptance
       *  by tightening the single-beam function.
       */
      if ((t -> ptrbm1 -> next) != NULL) {
         Rbm1k = 1;
         if (t -> ptrbm1 -> next -> kaon != 0)
            Rbm1k = (t -> ptrbm1 -> kaon)/(t -> ptrbm1 -> next -> kaon);
         Rbm1p = 1;
         if (t -> ptrbm1 -> next -> pion != 0)
            Rbm1p = (t -> ptrbm1 -> pion)/(t -> ptrbm1 -> next -> pion);
         Rcex = 1;
         if (t -> ptrbm1 -> next -> cex != 0)
            Rcex = (t -> ptrbm1 -> cex)/(t -> ptrbm1 -> next -> cex);
         Abm1 = 0;
         if (t -> ptrbm1 -> a != 0)
            Abm1 = (t -> ptrbm1 -> next -> a)/(t -> ptrbm1 -> a);

         kp2new = kp2old*Abm1;
         km2tnew = km2told*Abm1;
         km2bnew = km2bold*Abm1;
         bm1knew = bm1kold/Rbm1k;
         bm1pnew = bm1pold/Rbm1p;
         cexnew = cexold/Rcex;
         bm2knew = bm2kold*Abm1;
         bm2pnew = bm2pold*Abm1;
         totnew = kp2new + km2tnew + km2bnew + \
                  bm1knew + bm1pnew + cexnew + bm2knew + bm2pnew;
         accnew = accold*Abm1;
         if (accold == accnew) {
            if (totnew == totold) {
               RA = 999.;                     /* repeated entry -- skip */
	    } else {
               RA = (totold-totnew)/0.000001; /* more R, same A */
	    }
	 } else {
            if (totnew == totold) {
               RA = 999.;                     /* same R, less A -- skip */
	    } else {
               RA = (totold-totnew)/(accold-accnew); /* this should always */
                                                     /* be >0 and <infinity */
                                                     /* if the function has */
                                                     /* been tabulated */
                                                     /* properly */
	    }
	 }
         printf("Bm1 %f ", RA);

         if (RA > RAmax) {
            RAmax = RA;
            t -> next -> n = (totnew/totold)*(t -> n);
            t -> next -> a = (accnew/accold)*(t -> a);
            t -> next -> kp2 = kp2new;
            t -> next -> km2t = km2tnew;
            t -> next -> km2b = km2bnew;
            t -> next -> bm1k = bm1knew;
            t -> next -> bm1p = bm1pnew;
            t -> next -> cex = cexnew;
            t -> next -> bm2k = bm2knew;
            t -> next -> bm2p = bm2pnew;
            t -> next -> ptrpv = t -> ptrpv;
            t -> next -> ptrkp2 = t -> ptrkp2;
            t -> next -> ptrtd = t -> ptrtd;
            t -> next -> ptrkm2t = t -> ptrkm2t;
            t -> next -> ptrkm2b = t -> ptrkm2b;
            t -> next -> ptrbm1 = t -> ptrbm1 -> next;
            t -> next -> ptrbm2 = t -> ptrbm2;
         }
      }

      /*
       *  Get the new background level and acceptance
       *  by tightening the double-beam function.
       */
      if ((t -> ptrbm2 -> next) != NULL) {
         Rbm2k = 1;
         if (t -> ptrbm2 -> next -> kaon != 0)
            Rbm2k = (t -> ptrbm2 -> kaon)/(t -> ptrbm2 -> next -> kaon);
         Rbm2p = 1;
         if (t -> ptrbm2 -> next -> pion != 0)
            Rbm2p = (t -> ptrbm2 -> pion)/(t -> ptrbm2 -> next -> pion);
         Rcex = 1;
         if (t -> ptrbm2 -> next -> cex != 0)
            Rcex = (t -> ptrbm2 -> cex)/(t -> ptrbm2 -> next -> cex);
         Abm2 = 0;
         if (t -> ptrbm2 -> a != 0)
            Abm2 = (t -> ptrbm2 -> next -> a)/(t -> ptrbm2 -> a);

         kp2new = kp2old*Abm2;
         km2tnew = km2told*Abm2;
         km2bnew = km2bold*Abm2;
         bm1knew = bm1kold*Abm2;
         bm1pnew = bm1pold*Abm2;
         cexnew = cexold/Rcex;
         bm2knew = bm2kold/Rbm2k;
         bm2pnew = bm2pold/Rbm2p;
         totnew = kp2new + km2tnew + km2bnew + \
                  bm1knew + bm1pnew + cexnew + bm2knew + bm2pnew;
         accnew = accold*Abm2;
         if (accold == accnew) {
            if (totnew == totold) {
               RA = 999.;                     /* repeated entry -- skip */
	    } else {
               RA = (totold-totnew)/0.000001; /* more R, same A */
	    }
	 } else {
            if (totnew == totold) {
               RA = 999.;                     /* same R, less A -- skip */
	    } else {
               RA = (totold-totnew)/(accold-accnew); /* this should always */
                                                     /* be >0 and <infinity */
                                                     /* if the function has */
                                                     /* been tabulated */
                                                     /* properly */
	    }
	 }
         printf("Bm2 %f ", RA);

         if (RA > RAmax) {
            RAmax = RA;
            t -> next -> n = (totnew/totold)*(t -> n);
            t -> next -> a = (accnew/accold)*(t -> a);
            t -> next -> kp2 = kp2new;
            t -> next -> km2t = km2tnew;
            t -> next -> km2b = km2bnew;
            t -> next -> bm1k = bm1knew;
            t -> next -> bm1p = bm1pnew;
            t -> next -> cex = cexnew;
            t -> next -> bm2k = bm2knew;
            t -> next -> bm2p = bm2pnew;
            t -> next -> ptrpv = t -> ptrpv;
            t -> next -> ptrkp2 = t -> ptrkp2;
            t -> next -> ptrtd = t -> ptrtd;
            t -> next -> ptrkm2t = t -> ptrkm2t;
            t -> next -> ptrkm2b = t -> ptrkm2b;
            t -> next -> ptrbm1 = t -> ptrbm1;
            t -> next -> ptrbm2 = t -> ptrbm2 -> next;
         }
      }

      /*
       *  We've chosen the next-tighter point on the total background
       *  function by tightening the one background function which
       *  gives the maximum value of (totold-totnew)/(accold-accnew).
       *  Now we update the total background function structure, and
       *  continue the loop over individual function values until we've
       *  exhausted all possible sources of background rejection.
       */
      bgtotal.tail = t -> next;
      tot = bgtotal.tail -> kp2 +
            bgtotal.tail -> km2t +
            bgtotal.tail -> km2b +
            bgtotal.tail -> bm1k +
            bgtotal.tail -> bm1p +
            bgtotal.tail -> cex +
            bgtotal.tail -> bm2k +
            bgtotal.tail -> bm2p;
      printf("max %f %f \n %f %f %f %f %f %f %f %f \n %f %f %f %f %f %f %f \n",
             RAmax,tot,
             bgtotal.tail -> kp2,
             bgtotal.tail -> km2t,
             bgtotal.tail -> km2b,
             bgtotal.tail -> bm1k,
             bgtotal.tail -> bm1p,
             bgtotal.tail -> cex,
             bgtotal.tail -> bm2k,
             bgtotal.tail -> bm2p,
             bgtotal.tail -> ptrpv -> n,
             bgtotal.tail -> ptrkp2 -> n,
             bgtotal.tail -> ptrtd -> n,
             bgtotal.tail -> ptrkm2t -> n,
             bgtotal.tail -> ptrkm2b -> n,
             bgtotal.tail -> ptrbm1 -> n,
             bgtotal.tail -> ptrbm2 -> n);
      bgtotal.nvalues += 1;
      t -> next -> next = NULL;
      t -> next -> prev = t;
      t = t -> next;
   }

   /*
    *  Loop again over all the functions, this time loosening each
    *  to define the global background function outside the box.
    *  The one function which gives the largest absolute increase in
    *  acceptance per absolute increase in total background level
    *  is the function that is loosened at each step.
    *
    *  In the following code, it is assumed that the functions are
    *  tabulated/stored in order of decreasing background and acceptance.
    */

   t = bgtotal.box;

   while (((t -> ptrpv -> prev) != NULL) || \
          ((t -> ptrkp2 -> prev) != NULL) || \
          ((t -> ptrtd -> prev) != NULL) || \
          ((t -> ptrkm2t -> prev) != NULL) || \
          ((t -> ptrkm2b -> prev) != NULL) || \
          ((t -> ptrbm1 -> prev) != NULL) || \
          ((t -> ptrbm2 -> prev) != NULL)) {

      t -> prev = malloc(sizeof(TOTVALUE));

      kp2old = (t -> kp2);
      km2told = (t -> km2t);
      km2bold = (t -> km2b);
      bm1kold = (t -> bm1k);
      bm1pold = (t -> bm1p);
      cexold = (t -> cex);
      bm2kold = (t -> bm2k);
      bm2pold = (t -> bm2p);
      totold = kp2old + km2told + km2bold + \
               bm1kold + bm1pold + cexold + bm2kold + bm2pold;
      accold = (t -> a);

      RAmax = 0.;

      /*
       *  Get the new background level and acceptance
       *  by loosening the PV function.
       */
      if ((t -> ptrpv -> prev) != NULL) {
         Rpv = 1;
         if (t -> ptrpv -> prev -> n != 0)
            Rpv = (t -> ptrpv -> n)/(t -> ptrpv -> prev -> n);
         Apv = 0;
         if (t -> ptrpv -> a != 0)
            Apv = (t -> ptrpv -> prev -> a)/(t -> ptrpv -> a);

         kp2new = kp2old/Rpv;
         km2tnew = km2told*Apv;
         km2bnew = km2bold*Apv;
         bm1knew = bm1kold*Apv;
         bm1pnew = bm1pold*Apv;
         cexnew = cexold*Apv;
         bm2knew = bm2kold*Apv;
         bm2pnew = bm2pold*Apv;
         totnew = kp2new + km2tnew + km2bnew + \
                  bm1knew + bm1pnew + cexnew + bm2knew + bm2pnew;
         accnew = accold*Apv;
         if (accold == accnew) {              /* repeated entry, or more */
            RA = 999.;                        /* bg for same A  -- skip */ 
	 } else {
            if (totnew == totold) {
               RA = (accnew-accold)/0.000001; /* same bg, more A */
999.;                    
	    } else {
               RA = (accnew-accold)/(totnew-totold); /* this should always */
                                                     /* be >0 and <infinity */
                                                     /* if the function has */
                                                     /* been tabulated */
                                                     /* properly */
	    }
	 }
         printf("PV %f ", RA);

         if (RA > RAmax) {
            RAmax = RA;
            (t -> prev -> n) = (totnew/totold)*(t -> n);
            t -> prev -> a = (accnew/accold)*(t -> a);
            t -> prev -> kp2 = kp2new;
            t -> prev -> km2t = km2tnew;
            t -> prev -> km2b = km2bnew;
            t -> prev -> bm1k = bm1knew;
            t -> prev -> bm1p = bm1pnew;
            t -> prev -> cex = cexnew;
            t -> prev -> bm2k = bm2knew;
            t -> prev -> bm2p = bm2pnew;
            t -> prev -> ptrpv = t -> ptrpv -> prev;
            t -> prev -> ptrkp2 = t -> ptrkp2;
            t -> prev -> ptrtd = t -> ptrtd;
            t -> prev -> ptrkm2t = t -> ptrkm2t;
            t -> prev -> ptrkm2b = t -> ptrkm2b;
            t -> prev -> ptrbm1 = t -> ptrbm1;
            t -> prev -> ptrbm2 = t -> ptrbm2;
         }
      } 

      /*
       *  Get the new background level and acceptance
       *  by loosening the Kp2 kinematic function.
       */
      if ((t -> ptrkp2 -> prev) != NULL) {
         Rkp2 = 1;
         if (t -> ptrkp2 -> prev -> n != 0)
            Rkp2 = (t -> ptrkp2 -> n)/(t -> ptrkp2 -> prev -> n);
         Akp2 = 0;
         if (t -> ptrkp2 -> a != 0)
            Akp2 = (t -> ptrkp2 -> prev -> a)/(t -> ptrkp2 -> a);

         kp2new = kp2old/Rkp2;
         km2tnew = km2told;
         km2bnew = km2bold;
         bm1knew = bm1kold*Akp2;
         bm1pnew = bm1pold*Akp2;
         cexnew = cexold*Akp2;
         bm2knew = bm2kold*Akp2;
         bm2pnew = bm2pold*Akp2;
         totnew = kp2new + km2tnew + km2bnew + \
                  bm1knew + bm1pnew + cexnew + bm2knew + bm2pnew;
         accnew = accold*Akp2;
         if (accold == accnew) {              /* repeated entry, or more */
            RA = 999.;                        /* bg for same A  -- skip */ 
	 } else {
            if (totnew == totold) {
               RA = (accnew-accold)/0.000001; /* same bg, more A */
999.;                    
	    } else {
               RA = (accnew-accold)/(totnew-totold); /* this should always */
                                                     /* be >0 and <infinity */
                                                     /* if the function has */
                                                     /* been tabulated */
                                                     /* properly */
	    }
	 }
         printf("Kp2 %f ", RA);

         if (RA > RAmax) {
            RAmax = RA;
            (t -> prev -> n) = (totnew/totold)*(t -> n);
            t -> prev -> a = (accnew/accold)*(t -> a);
            t -> prev -> kp2 = kp2new;
            t -> prev -> km2t = km2tnew;
            t -> prev -> km2b = km2bnew;
            t -> prev -> bm1k = bm1knew;
            t -> prev -> bm1p = bm1pnew;
            t -> prev -> cex = cexnew;
            t -> prev -> bm2k = bm2knew;
            t -> prev -> bm2p = bm2pnew;
            t -> prev -> ptrpv = t -> ptrpv;
            t -> prev -> ptrkp2 = t -> ptrkp2 -> prev;
            t -> prev -> ptrtd = t -> ptrtd;
            t -> prev -> ptrkm2t = t -> ptrkm2t;
            t -> prev -> ptrkm2b = t -> ptrkm2b;
            t -> prev -> ptrbm1 = t -> ptrbm1;
            t -> prev -> ptrbm2 = t -> ptrbm2;
         }
      } 

      /*
       *  Get the new background level and acceptance
       *  by loosening the TD function.
       */
      if ((t -> ptrtd -> prev) != NULL) {
         Rtd = 1;
         if (t -> ptrtd -> prev -> n != 0)
            Rtd = (t -> ptrtd -> n)/(t -> ptrtd -> prev -> n);
         Atd = 0;
         if (t -> ptrtd -> a != 0)
            Atd = (t -> ptrtd -> prev -> a)/(t -> ptrtd -> a);

         kp2new = kp2old*Atd;
         km2tnew = km2told/Rtd;
         km2bnew = km2bold/Rtd;
         bm1knew = bm1kold*Atd;
         bm1pnew = bm1pold*Atd;
         cexnew = cexold*Atd;
         bm2knew = bm2kold*Atd;
         bm2pnew = bm2pold*Atd;
         totnew = kp2new + km2tnew + km2bnew + \
                  bm1knew + bm1pnew + cexnew + bm2knew + bm2pnew;
         accnew = accold*Atd;
         if (accold == accnew) {              /* repeated entry, or more */
            RA = 999.;                        /* bg for same A  -- skip */ 
	 } else {
            if (totnew == totold) {
               RA = (accnew-accold)/0.000001; /* same bg, more A */
999.;                    
	    } else {
               RA = (accnew-accold)/(totnew-totold); /* this should always */
                                                     /* be >0 and <infinity */
                                                     /* if the function has */
                                                     /* been tabulated */
                                                     /* properly */
	    }
	 }
         printf("TD %f ", RA);

         if (RA > RAmax) {
            RAmax = RA;
            (t -> prev -> n) = (totnew/totold)*(t -> n);
            t -> prev -> a = (accnew/accold)*(t -> a);
            t -> prev -> kp2 = kp2new;
            t -> prev -> km2t = km2tnew;
            t -> prev -> km2b = km2bnew;
            t -> prev -> bm1k = bm1knew;
            t -> prev -> bm1p = bm1pnew;
            t -> prev -> cex = cexnew;
            t -> prev -> bm2k = bm2knew;
            t -> prev -> bm2p = bm2pnew;
            t -> prev -> ptrpv = t -> ptrpv;
            t -> prev -> ptrkp2 = t -> ptrkp2;
            t -> prev -> ptrtd = t -> ptrtd -> prev;
            t -> prev -> ptrkm2t = t -> ptrkm2t;
            t -> prev -> ptrkm2b = t -> ptrkm2b;
            t -> prev -> ptrbm1 = t -> ptrbm1;
            t -> prev -> ptrbm2 = t -> ptrbm2;
         }
      } 

      /*
       *  Get the new background level and acceptance
       *  by loosening the Km2 range-tail kinematic function.
       */
      if ((t -> ptrkm2t -> prev) != NULL) {
         Rkm2t = 1;
         if (t -> ptrkm2t -> prev -> n != 0)
            Rkm2t = (t -> ptrkm2t -> n)/(t -> ptrkm2t -> prev -> n);
         Akm2t = 0;
         if (t -> ptrkm2t -> a != 0)
            Akm2t = (t -> ptrkm2t -> prev -> a)/(t -> ptrkm2t -> a);

         kp2new = kp2old;
         km2tnew = km2told/Rkm2t;
         km2bnew = km2bold;
         bm1knew = bm1kold*Akm2t;
         bm1pnew = bm1pold*Akm2t;
         cexnew = cexold*Akm2t;
         bm2knew = bm2kold*Akm2t;
         bm2pnew = bm2pold*Akm2t;
         totnew = kp2new + km2tnew + km2bnew + \
                  bm1knew + bm1pnew + cexnew + bm2knew + bm2pnew;
         accnew = accold*Akm2t;
         if (accold == accnew) {              /* repeated entry, or more */
            RA = 999.;                        /* bg for same A  -- skip */ 
	 } else {
            if (totnew == totold) {
               RA = (accnew-accold)/0.000001; /* same bg, more A */
999.;                    
	    } else {
               RA = (accnew-accold)/(totnew-totold); /* this should always */
                                                     /* be >0 and <infinity */
                                                     /* if the function has */
                                                     /* been tabulated */
                                                     /* properly */
	    }
	 }
         printf("Km2t %f ", RA);

         if (RA > RAmax) {
            RAmax = RA;
            (t -> prev -> n) = (totnew/totold)*(t -> n);
            t -> prev -> a = (accnew/accold)*(t -> a);
            t -> prev -> kp2 = kp2new;
            t -> prev -> km2t = km2tnew;
            t -> prev -> km2b = km2bnew;
            t -> prev -> bm1k = bm1knew;
            t -> prev -> bm1p = bm1pnew;
            t -> prev -> cex = cexnew;
            t -> prev -> bm2k = bm2knew;
            t -> prev -> bm2p = bm2pnew;
            t -> prev -> ptrpv = t -> ptrpv;
            t -> prev -> ptrkp2 = t -> ptrkp2;
            t -> prev -> ptrtd = t -> ptrtd;
            t -> prev -> ptrkm2t = t -> ptrkm2t -> prev;
            t -> prev -> ptrkm2b = t -> ptrkm2b;
            t -> prev -> ptrbm1 = t -> ptrbm1;
            t -> prev -> ptrbm2 = t -> ptrbm2;
         }
      } 

      /*
       *  Get the new background level and acceptance
       *  by loosening the muon-band kinematic function.
       */
      if ((t -> ptrkm2b -> prev) != NULL) {
         Rkm2b = 1;
         if (t -> ptrkm2b -> prev -> n != 0)
            Rkm2b = (t -> ptrkm2b -> n)/(t -> ptrkm2b -> prev -> n);
         Akm2b = 0;
         if (t -> ptrkm2b -> a != 0)
            Akm2b = (t -> ptrkm2b -> prev -> a)/(t -> ptrkm2b -> a);

         kp2new = kp2old;
         km2tnew = km2told;
         km2bnew = km2bold/Rkm2b;
         bm1knew = bm1kold*Akm2b;
         bm1pnew = bm1pold*Akm2b;
         cexnew = cexold*Akm2b;
         bm2knew = bm2kold*Akm2b;
         bm2pnew = bm2pold*Akm2b;
         totnew = kp2new + km2tnew + km2bnew + \
                  bm1knew + bm1pnew + cexnew + bm2knew + bm2pnew;
         accnew = accold*Akm2b;
         if (accold == accnew) {              /* repeated entry, or more */
            RA = 999.;                        /* bg for same A  -- skip */ 
	 } else {
            if (totnew == totold) {
               RA = (accnew-accold)/0.000001; /* same bg, more A */
999.;                    
	    } else {
               RA = (accnew-accold)/(totnew-totold); /* this should always */
                                                     /* be >0 and <infinity */
                                                     /* if the function has */
                                                     /* been tabulated */
                                                     /* properly */
	    }
	 }
         printf("Km2b %f ", RA);

         if (RA > RAmax) {
            RAmax = RA;
            (t -> prev -> n) = (totnew/totold)*(t -> n);
            t -> prev -> a = (accnew/accold)*(t -> a);
            t -> prev -> kp2 = kp2new;
            t -> prev -> km2t = km2tnew;
            t -> prev -> km2b = km2bnew;
            t -> prev -> bm1k = bm1knew;
            t -> prev -> bm1p = bm1pnew;
            t -> prev -> cex = cexnew;
            t -> prev -> bm2k = bm2knew;
            t -> prev -> bm2p = bm2pnew;
            t -> prev -> ptrpv = t -> ptrpv;
            t -> prev -> ptrkp2 = t -> ptrkp2;
            t -> prev -> ptrtd = t -> ptrtd;
            t -> prev -> ptrkm2t = t -> ptrkm2t;
            t -> prev -> ptrkm2b = t -> ptrkm2b -> prev;
            t -> prev -> ptrbm1 = t -> ptrbm1;
            t -> prev -> ptrbm2 = t -> ptrbm2;
         }
      } 

      /*
       *  Get the new background level and acceptance
       *  by loosening the single-beam function.
       */
      if ((t -> ptrbm1 -> prev) != NULL) {
         Rbm1k = 1;
         if (t -> ptrbm1 -> prev -> kaon != 0)
            Rbm1k = (t -> ptrbm1 -> kaon)/(t -> ptrbm1 -> prev -> kaon);
         Rbm1p = 1;
         if (t -> ptrbm1 -> prev -> pion != 0)
            Rbm1p = (t -> ptrbm1 -> pion)/(t -> ptrbm1 -> prev -> pion);
         Rcex = 1;
         if (t -> ptrbm1 -> prev -> cex != 0)
            Rcex = (t -> ptrbm1 -> cex)/(t -> ptrbm1 -> prev -> cex);
         Abm1 = 0;
         if (t -> ptrbm1 -> a != 0)
            Abm1 = (t -> ptrbm1 -> prev -> a)/(t -> ptrbm1 -> a);

         kp2new = kp2old*Abm1;
         km2tnew = km2told*Abm1;
         km2bnew = km2bold*Abm1;
         bm1knew = bm1kold/Rbm1k;
         bm1pnew = bm1pold/Rbm1p;
         cexnew = cexold/Rcex;
         bm2knew = bm2kold*Abm1;
         bm2pnew = bm2pold*Abm1;
         totnew = kp2new + km2tnew + km2bnew + \
                  bm1knew + bm1pnew + cexnew + bm2knew + bm2pnew;
         accnew = accold*Abm1;
         if (accold == accnew) {              /* repeated entry, or more */
            RA = 999.;                        /* bg for same A  -- skip */ 
	 } else {
            if (totnew == totold) {
               RA = (accnew-accold)/0.000001; /* same bg, more A */
999.;                    
	    } else {
               RA = (accnew-accold)/(totnew-totold); /* this should always */
                                                     /* be >0 and <infinity */
                                                     /* if the function has */
                                                     /* been tabulated */
                                                     /* properly */
	    }
	 }
         printf("Bm1 %f ", RA);

         if (RA > RAmax) {
            RAmax = RA;
            (t -> prev -> n) = (totnew/totold)*(t -> n);
            t -> prev -> a = (accnew/accold)*(t -> a);
            t -> prev -> kp2 = kp2new;
            t -> prev -> km2t = km2tnew;
            t -> prev -> km2b = km2bnew;
            t -> prev -> bm1k = bm1knew;
            t -> prev -> bm1p = bm1pnew;
            t -> prev -> cex = cexnew;
            t -> prev -> bm2k = bm2knew;
            t -> prev -> bm2p = bm2pnew;
            t -> prev -> ptrpv = t -> ptrpv;
            t -> prev -> ptrkp2 = t -> ptrkp2;
            t -> prev -> ptrtd = t -> ptrtd;
            t -> prev -> ptrkm2t = t -> ptrkm2t;
            t -> prev -> ptrkm2b = t -> ptrkm2b;
            t -> prev -> ptrbm1 = t -> ptrbm1 -> prev;
            t -> prev -> ptrbm2 = t -> ptrbm2;
         }
      } 

      /*
       *  Get the new background level and acceptance
       *  by loosening the double-beam function.
       */
      if ((t -> ptrbm2 -> prev) != NULL) {
         Rbm2k = 1;
         if (t -> ptrbm2 -> prev -> kaon != 0)
            Rbm2k = (t -> ptrbm2 -> kaon)/(t -> ptrbm2 -> prev -> kaon);
         Rbm2p = 1;
         if (t -> ptrbm2 -> prev -> pion != 0)
            Rbm2p = (t -> ptrbm2 -> pion)/(t -> ptrbm2 -> prev -> pion);
         Rcex = 1;
         if (t -> ptrbm2 -> prev -> cex != 0)
            Rcex = (t -> ptrbm2 -> cex)/(t -> ptrbm2 -> prev -> cex);
         Abm2 = 0;
         if (t -> ptrbm2 -> a != 0)
            Abm2 = (t -> ptrbm2 -> prev -> a)/(t -> ptrbm2 -> a);

         kp2new = kp2old*Abm2;
         km2tnew = km2told*Abm2;
         km2bnew = km2bold*Abm2;
         bm1knew = bm1kold*Abm2;
         bm1pnew = bm1pold*Abm2;
         cexnew = cexold/Rcex;
         bm2knew = bm2kold/Rbm2k;
         bm2pnew = bm2pold/Rbm2p;
         totnew = kp2new + km2tnew + km2bnew + \
                  bm1knew + bm1pnew + cexnew + bm2knew + bm2pnew;
         accnew = accold*Abm2;
         if (accold == accnew) {              /* repeated entry, or more */
            RA = 999.;                        /* bg for same A  -- skip */ 
	 } else {
            if (totnew == totold) {
               RA = (accnew-accold)/0.000001; /* same bg, more A */
999.;                    
	    } else {
               RA = (accnew-accold)/(totnew-totold); /* this should always */
                                                     /* be >0 and <infinity */
                                                     /* if the function has */
                                                     /* been tabulated */
                                                     /* properly */
	    }
	 }
         printf("Bm2 %f ", RA);

         if (RA > RAmax) {
            RAmax = RA;
            (t -> prev -> n) = (totnew/totold)*(t -> n);
            t -> prev -> a = (accnew/accold)*(t -> a);
            t -> prev -> kp2 = kp2new;
            t -> prev -> km2t = km2tnew;
            t -> prev -> km2b = km2bnew;
            t -> prev -> bm1k = bm1knew;
            t -> prev -> bm1p = bm1pnew;
            t -> prev -> cex = cexnew;
            t -> prev -> bm2k = bm2knew;
            t -> prev -> bm2p = bm2pnew;
            t -> prev -> ptrpv = t -> ptrpv;
            t -> prev -> ptrkp2 = t -> ptrkp2;
            t -> prev -> ptrtd = t -> ptrtd;
            t -> prev -> ptrkm2t = t -> ptrkm2t;
            t -> prev -> ptrkm2b = t -> ptrkm2b;
            t -> prev -> ptrbm1 = t -> ptrbm1;
            t -> prev -> ptrbm2 = t -> ptrbm2 -> prev;
         }
      } 

      /*
       *  We've chosen the next-looser point on the total background
       *  function by loosening the one background function which
       *  gives the maximum value of (accnew-accold)/(totnew-totold).
       *  Now we update the total background function structure, and
       *  continue the loop over individual function values until we've
       *  exhausted all possible sources of cut loosening.
       */
      bgtotal.head = t -> prev;
      tot = bgtotal.head -> kp2 +
            bgtotal.head -> km2t +
            bgtotal.head -> km2b +
            bgtotal.head -> bm1k +
            bgtotal.head -> bm1p +
            bgtotal.head -> cex +
            bgtotal.head -> bm2k +
            bgtotal.head -> bm2p;
      printf("max %f %f \n %f %f %f %f %f %f %f %f \n %f %f %f %f %f %f %f \n",
             RAmax,tot,
             bgtotal.head -> kp2,
             bgtotal.head -> km2t,
             bgtotal.head -> km2b,
             bgtotal.head -> bm1k,
             bgtotal.head -> bm1p,
             bgtotal.head -> cex,
             bgtotal.head -> bm2k,
             bgtotal.head -> bm2p,
             bgtotal.head -> ptrpv -> n,
             bgtotal.head -> ptrkp2 -> n,
             bgtotal.head -> ptrtd -> n,
             bgtotal.head -> ptrkm2t -> n,
             bgtotal.head -> ptrkm2b -> n,
             bgtotal.head -> ptrbm1 -> n,
             bgtotal.head -> ptrbm2 -> n);
      bgtotal.nvalues += 1;
      t -> prev -> prev = NULL;
      t -> prev -> next = t;
      t = t -> prev;
   }

   printf("\\begin\{center\} \n");
   printf("\\begin\{tabular\}\{\|l\|r\|r\|\|r\|r\|r\|r\|r\|r\|r\|\} \n");
   printf("\\hline \n");
   printf(" & \$\\cal\{N\}\$ & \$\\cal\{A\}\$ & \$N\_\{PV\}\$ & \$N\_\{K\\pi 2\}\$ & \$N\_\{TD\}\$ & \$N\_\{\\mu tail\}\$ & \$N\_\{\\mu band\}\$ & \$N\_\{BM1\}\$ & \$N\_\{BM2\}\$ \\\\ \n");
   printf("\\hline \n");
   t = bgtotal.head;
   for (i = 0; i < bgtotal.nvalues; i++) {
      printf("%4d & %12.5f & %8.5f & %9.5f & %8.5f & %9.5f & %8.5f & %8.5f & %10.5f & %11.5f \\\\ \n", i+1, \
             t -> n, t -> a, \
             t -> ptrpv -> n,
             t -> ptrkp2 -> n,
             t -> ptrtd -> n,
             t -> ptrkm2t -> n,
             t -> ptrkm2b -> n,
             t -> ptrbm1 -> n,
             t -> ptrbm2 -> n);
      t = t -> next;
      if ((i+1)%40 == 0) {
         printf("\\hline \n");
         printf("\\end{tabular\} \n\n");
         printf("\\pagebreak \n\n");
         printf("\\begin\{tabular\}\{\|l\|r\|r\|\|r\|r\|r\|r\|r\|r\|r\|\} \n");
         printf("\\hline \n");
         printf(" & \$\\cal\{N\}\$ & \$\\cal\{A\}\$ & \$N\_\{PV\}\$ & \$N\_\{K\\pi 2\}\$ & \$N\_\{TD\}\$ & \$N\_\{\\mu tail\}\$ & \$N\_\{\\mu band\}\$ & \$N\_\{BM1\}\$ & \$N\_\{BM2\}\$ \\\\ \n");
         printf("\\hline \n");
      }
   }
   printf("\\hline \n");
   printf("\\end\{tabular\} \n");
   printf("\\end\{center\} \n\n");
   printf("\\end\{document\} \n");

   printf("\n\n\n");
   t = bgtotal.head;
   for (i = 0; i < bgtotal.nvalues; i++) {
      printf("%12.5f %8.5f \n", t -> n, t -> a);
      t = t -> next;
   }

   /*
    *  Free the used memory.
    */
   p = bgpv.head;
   for (i = 0; i < bgpv.nvalues; i++) {
      free(p);
      p = p -> next;
   }
   p = bgkp2.head;
   for (i = 0; i < bgkp2.nvalues; i++) {
      free(p);
      p = p -> next;
   }
   p = bgtd.head;
   for (i = 0; i < bgtd.nvalues; i++) {
      free(p);
      p = p -> next;
   }
   p = bgkm2t.head;
   for (i = 0; i < bgkm2t.nvalues; i++) {
      free(p);
      p = p -> next;
   }
   p = bgkm2b.head;
   for (i = 0; i < bgkm2b.nvalues; i++) {
      free(p);
      p = p -> next;
   }
   q = bgbm1.head;
   for (i = 0; i < bgbm1.nvalues; i++) {
      free(q);
      q = q -> next;
   }
   q = bgbm2.head;
   for (i = 0; i < bgbm2.nvalues; i++) {
      free(q);
      q = q -> next;
   }
   t = bgtotal.head;
   for (i = 0; i < bgtotal.nvalues; i++) {
      free(t);
      t = t -> next;
   }
}
